---
import BaseHead from './BaseHead.astro';
import CustomHeader from './CustomHeader.astro';
import CustomFooter from './CustomFooter.astro';

// Receive headings from page content
const { headings } = Astro.props;

// Build a nested tree structure from docs content
const modules = import.meta.glob('../content/docs/**/*.{md,mdx}', { eager: true });
const docsRaw = import.meta.glob('../content/docs/**/*.{md,mdx}', { eager: true, as: 'raw' });
const blogInfo = import.meta.glob('../content/blog/**/*.{md,mdx}', { eager: true });
const blogRaw = import.meta.glob('../content/blog/**/*.{md,mdx}', { eager: true, as: 'raw' });
function buildTree() {
  const tree = [];
  for (const [filePath, mod] of Object.entries(modules)) {
    let rawKey = filePath.replace('../content/docs/', '').replace(/\.(md|mdx)$/, '');
    if (rawKey === 'index') continue;
    const segments = rawKey.split('/');
    let siblings = tree;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      let node = siblings.find(n => n.name === segment);
      if (!node) {
        node = { name: segment, label: segment.replace(/-/g, ' '), path: null, children: [] };
        siblings.push(node);
      }
      siblings = node.children;
      if (i === segments.length - 1) {
        node.path = '/' + rawKey.toLowerCase() + '/';
        node.label = mod.frontmatter?.title || node.label;
      }
    }
  }
  return tree;
}
const docTree = buildTree();

// Determine breadcrumb based on current path
const currentPath = Astro.url.pathname.replace(/\/$/, '').toLowerCase();
function findPath(nodes, parents = []) {
  for (const node of nodes) {
    const nodePath = node.path?.replace(/\/$/, '').toLowerCase();
    if (nodePath === currentPath) {
      return [...parents, node];
    }
    if (node.children?.length) {
      const result = findPath(node.children, [...parents, node]);
      if (result) return result;
    }
  }
  return null;
}
const breadcrumbNodes = findPath(docTree) || [];

const searchIndex = [];
for (const [file, mod] of Object.entries(modules)) {
  const rawKey = file.replace('../content/docs/', '').replace(/\.(md|mdx)$/, '');
  searchIndex.push({
    title: mod.frontmatter?.title || '',
    tags: mod.frontmatter?.tags || [],
    body: docsRaw[file],
    url: '/' + rawKey.toLowerCase() + '/',
  });
}
for (const [file, mod] of Object.entries(blogInfo)) {
  const slug = file.replace('../content/blog/', '').replace(/\.(md|mdx)$/, '');
  searchIndex.push({
    title: mod.frontmatter?.title || '',
    tags: mod.frontmatter?.tags || [],
    body: blogRaw[file],
    url: '/blog/' + slug.toLowerCase() + '/',
  });
}

---
<html lang="en">
  <head>
    <BaseHead />
  </head>
  <body class="docs-layout">
    <CustomHeader isDocs={true} />
    <div class="docs-container container-fluid">
      <aside class="sidebar-left">
        <div class="position-relative mb-3">
          <input id="doc-search" type="search" class="form-control" placeholder="Search docs..." autocomplete="off" />
          <ul id="search-results" class="list-group position-absolute w-100 d-none search-dropdown"></ul>
        </div>
        <div class="accordion" id="docAccordion">
          {(() => {
            function renderNodes(nodes, activeNames) {
              return nodes.map(node => {
                if (node.children?.length) {
                  const open = activeNames.includes(node.name) ? ' open' : '';
                  return (
                    <li class={`doc-folder list-group-item${open}`}>
                      <span class="folder-label">{node.label}</span>
                      <ul class="list-group list-group-flush ms-2">
                        {renderNodes(node.children, activeNames)}
                      </ul>
                    </li>
                  );
                }
                const isActive = node.path?.replace(/\/$/, '').toLowerCase() === currentPath;
                return (
                  <li class="doc-link-item list-group-item">
                    <a class={`text-decoration-none${isActive ? ' doc-active' : ''}`} href={node.path}>{node.label}</a>

                  </li>
                );
              });
            }
            const activeNames = breadcrumbNodes.map(n => n.name);
            return docTree.map((cat, i) => {
              const activeCat = activeNames[0] === cat.name;
              return (
                <div class="accordion-item" key={i}>
                  <h2 class="accordion-header" id={`heading-${i}`}>
                    <button class={`accordion-button${activeCat ? '' : ' collapsed'}`} type="button" data-bs-toggle="collapse" data-bs-target={`#acc-${i}`} aria-expanded={activeCat ? 'true' : 'false'} aria-controls={`acc-${i}`}>
                      {cat.label}
                    </button>
                  </h2>
                  <div id={`acc-${i}`} class={`accordion-collapse collapse${activeCat ? ' show' : ''}`} data-bs-parent="#docAccordion">
                    <div class="accordion-body p-0">
                      <ul class="list-group list-group-flush">
                        {renderNodes(cat.children, activeNames)}
                      </ul>
                    </div>
                  </div>
                </div>
              );
            });
          })()}
        </div>
      </aside>
      <main id="main-content" class="docs-main">
        {breadcrumbNodes.length ? (
          <nav aria-label="Breadcrumb" class="mb-3">
            <ol class="breadcrumb">
              <li class="breadcrumb-item"><a href="/">Home</a></li>
              {breadcrumbNodes.map((node, idx) => (
                idx < breadcrumbNodes.length - 1 ? (
                  <li class="breadcrumb-item" key={idx}><a href={node.path}>{node.label}</a></li>
                ) : (
                  <li class="breadcrumb-item active" aria-current="page" key={idx}>{node.label}</li>
                )
              ))}
            </ol>
          </nav>
        ) : null}
        <slot />
      </main>
      <aside class="sidebar-right">
        <nav>
          <ul class="list-unstyled">
            {headings?.map(h => (
              <li style={`margin-left: ${h.depth * 0.5}rem`}>
                <a href={`#${h.slug}`}>{h.text}</a>
              </li>
            ))}
          </ul>
        </nav>
      </aside>
    </div>
    <CustomFooter />
    <script id="search-data" type="application/json">{JSON.stringify(searchIndex)}</script>
    <script client:load>
      const onReady = () => {

        const searchData = JSON.parse(document.getElementById('search-data').textContent);
        const input = document.getElementById('doc-search');
        const results = document.getElementById('search-results');

      function fuzzy(text, query) {
        const words = query.toLowerCase().split(/\s+/).filter(Boolean);
        const t = text.toLowerCase();
        return words.every(w => t && t.includes(w));
      }

      input.addEventListener('input', () => {
        const q = input.value.trim();
        results.innerHTML = '';
        if (!q) {
          results.classList.add('d-none');
          return;
        }
        const matches = searchData.filter(item => fuzzy(item.title + ' ' + item.body + ' ' + item.tags.join(' '), q));
        matches.slice(0, 10).forEach(m => {
          const li = document.createElement('li');
          li.className = 'list-group-item';
          li.innerHTML = `<a href="${m.url}" class="text-decoration-none">${m.title}</a>`;
          results.appendChild(li);
        });
        results.classList.toggle('d-none', matches.length === 0);
      });

      document.addEventListener('click', (e) => {
        if (!results.contains(e.target) && e.target !== input) {
          results.classList.add('d-none');
        }
      });

      // Toggle folders in the sidebar
        document.querySelectorAll('.doc-folder > .folder-label').forEach(label => {
          label.addEventListener('click', () => {
            label.parentElement.classList.toggle('open');
          });
        });

      // Keep current page link highlighted and its folder open
        const normalizePath = (p) => p.toLowerCase().replace(/\/?(index\.html)?$/, '');
        const current = normalizePath(window.location.pathname);
        const link = Array.from(document.querySelectorAll('.sidebar-left a')).find(a => {
          const href = a.getAttribute('href');
          if (!href) return false;
          return normalizePath(href) === current;
        });
        if (link) {
          link.classList.add('doc-active');

          let folder = link.closest('.doc-folder');
          while (folder) {
            folder.classList.add('open');
            folder = folder.parentElement.closest('.doc-folder');
          }

          const item = link.closest('.accordion-item');
          if (item) {
            const collapse = item.querySelector('.accordion-collapse');
            if (collapse) collapse.classList.add('show');
            const heading = item.querySelector('.accordion-button');
            if (heading) {
              heading.classList.remove('collapsed');
              heading.setAttribute('aria-expanded', 'true');
            }
          }
        }

      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', onReady);
      } else {
        onReady();
      }

    </script>
  </body>
</html>