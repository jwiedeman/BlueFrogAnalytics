---
import BaseHead from './BaseHead.astro';
import CustomHeader from './CustomHeader.astro';
import CustomFooter from './CustomFooter.astro';
import FirebaseScripts from './FirebaseScripts.astro';

// Receive headings from page content
const { headings, title, description } = Astro.props;

// Build a nested tree structure from docs content
const modules = import.meta.glob('../content/docs/**/*.{md,mdx}', { eager: true });
const docsRaw = import.meta.glob('../content/docs/**/*.{md,mdx}', { eager: true, as: 'raw' });
const blogInfo = import.meta.glob('../content/blog/**/*.{md,mdx}', { eager: true });
const blogRaw = import.meta.glob('../content/blog/**/*.{md,mdx}', { eager: true, as: 'raw' });
function buildTree() {
  const tree = [];
  for (const [filePath, mod] of Object.entries(modules)) {
    let rawKey = filePath.replace('../content/docs/', '').replace(/\.(md|mdx)$/, '');
    if (rawKey === 'index') continue;
    const segments = rawKey.split('/');
    let siblings = tree;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      let node = siblings.find(n => n.name === segment);
      if (!node) {
        node = { name: segment, label: segment.replace(/-/g, ' '), path: null, children: [] };
        siblings.push(node);
      }
      siblings = node.children;
      if (i === segments.length - 1) {
        node.path = '/' + rawKey.toLowerCase() + '/';
        node.label = mod.frontmatter?.title || node.label;
      }
    }
  }
  return tree;
}
const docTree = buildTree();
function sortTree(nodes) {
  nodes.sort((a, b) => a.name.localeCompare(b.name));
  for (const n of nodes) {
    if (n.children?.length) sortTree(n.children);
  }
}
sortTree(docTree);
const introIndex = docTree.findIndex(n => n.name.toLowerCase() === 'introduction');
if (introIndex > -1) {
  const [intro] = docTree.splice(introIndex, 1);
  docTree.unshift(intro);
}

// Determine breadcrumb based on current path
const currentPath = Astro.url.pathname.replace(/\/$/, '').toLowerCase();
function findPath(nodes, parents = []) {
  for (const node of nodes) {
    const nodePath = node.path?.replace(/\/$/, '').toLowerCase();
    if (nodePath === currentPath) {
      return [...parents, node];
    }
    if (node.children?.length) {
      const result = findPath(node.children, [...parents, node]);
      if (result) return result;
    }
  }
  return null;
}
const breadcrumbNodes = findPath(docTree) || [];

const searchIndex = [];
for (const [file, mod] of Object.entries(modules)) {
  const rawKey = file.replace('../content/docs/', '').replace(/\.(md|mdx)$/, '');
  searchIndex.push({
    title: mod.frontmatter?.title || '',
    tags: mod.frontmatter?.tags || [],
    body: docsRaw[file],
    url: '/' + rawKey.toLowerCase() + '/',
  });
}
for (const [file, mod] of Object.entries(blogInfo)) {
  const slug = file.replace('../content/blog/', '').replace(/\.(md|mdx)$/, '');
  searchIndex.push({
    title: mod.frontmatter?.title || '',
    tags: mod.frontmatter?.tags || [],
    body: blogRaw[file],
    url: '/blog/' + slug.toLowerCase() + '/',
  });
}

---
<html lang="en">
  <head>
    <BaseHead title={title} description={description} />
  </head>
  <body class="docs-layout d-flex flex-column min-vh-100">
    <CustomHeader isDocs={true} />
    <div class="docs-container container-fluid flex-grow-1">
      <aside class="sidebar-left">
        <div class="position-relative mb-3">
          <input id="doc-search" type="search" class="form-control" placeholder="Search docs..." autocomplete="off" />
        </div>
        <div class="accordion" id="docAccordion">
          {(() => {
            function renderNodes(nodes, activeNames, prefix = '') {
              return nodes.map((node, idx) => {
                const id = `${prefix}${idx}`;
                if (node.children?.length) {
                  const isOpen = activeNames.includes(node.name);
                  return (
                    <li class="list-group-item p-0" key={id}>
                      <button class={`btn btn-toggle w-100 text-start${isOpen ? '' : ' collapsed'}`} type="button" data-bs-toggle="collapse" data-bs-target={`#tree-${id}`} aria-expanded={isOpen ? 'true' : 'false'}>
                        {node.label}
                      </button>
                      <div class={`collapse${isOpen ? ' show' : ''}`} id={`tree-${id}`}>
                        <ul class="btn-toggle-nav list-unstyled">
                          {renderNodes(node.children, activeNames, `${id}-`)}
                        </ul>
                      </div>
                    </li>
                  );
                }
                const isActive = node.path?.replace(/\/$/, '').toLowerCase() === currentPath;
                return (
                  <li class="doc-link-item list-group-item p-0" key={id}>
                    <a class={`text-decoration-none d-block ps-4${isActive ? ' doc-active' : ''}`} href={node.path}>{node.label}</a>
                  </li>
                );
              });
            }
            const activeNames = breadcrumbNodes.map(n => n.name);
            return docTree.map((cat, i) => {
              const activeCat = activeNames[0] === cat.name;
              return (
                <div class="accordion-item" key={i}>
                  <h2 class="accordion-header" id={`heading-${i}`}>
                    <button class={`accordion-button${activeCat ? '' : ' collapsed'}`} type="button" data-bs-toggle="collapse" data-bs-target={`#acc-${i}`} aria-expanded={activeCat ? 'true' : 'false'} aria-controls={`acc-${i}`}>
                      {cat.label}
                    </button>
                  </h2>
                  <div id={`acc-${i}`} class={`accordion-collapse collapse${activeCat ? ' show' : ''}`} data-bs-parent="#docAccordion">
                    <div class="accordion-body p-0">
                      <ul class="list-group list-group-flush">
                        {renderNodes(cat.children, activeNames, `${i}-`)}
                      </ul>
                    </div>
                  </div>
                </div>
              );
            });
          })()}
        </div>
      </aside>
      <main id="main-content" class="docs-main">
        {breadcrumbNodes.length ? (
          <nav aria-label="Breadcrumb" class="mb-3">
            <ol class="breadcrumb">
              <li class="breadcrumb-item"><a href="/">Home</a></li>
              {breadcrumbNodes.map((node, idx) => (
                idx < breadcrumbNodes.length - 1 ? (
                  <li class="breadcrumb-item" key={idx}><a href={node.path}>{node.label}</a></li>
                ) : (
                  <li class="breadcrumb-item active" aria-current="page" key={idx}>{node.label}</li>
                )
              ))}
            </ol>
          </nav>
        ) : null}
        <slot />
      </main>
      <aside class="sidebar-right">
        <nav>
          <ul class="list-unstyled">
            {headings?.map(h => (
              <li style={`margin-left: ${h.depth * 0.5}rem`}>
                <a href={`#${h.slug}`}>{h.text}</a>
              </li>
            ))}
          </ul>
        </nav>
      </aside>
    </div>
    <div id="search-panel" class="search-panel d-none">
      <div class="container py-3">
        <ul id="search-results" class="list-group search-dropdown"></ul>
      </div>
    </div>
    <CustomFooter />
    <FirebaseScripts />
    <!-- Docs search logic -->
    <script client:load is:inline define:vars={{ searchIndex }}>
      const onReady = () => {

        const searchData = searchIndex;
        const input = document.getElementById('doc-search');
        const panel = document.getElementById('search-panel');
        const results = document.getElementById('search-results');


        const updatePanelPos = () => {
          const rect = input.getBoundingClientRect();
          const top = rect.bottom;
          panel.style.top = `${top}px`;
          panel.style.maxHeight = `calc(100vh - ${top}px)`;
        };

        updatePanelPos();

      function levenshtein(a, b) {
        const m = a.length, n = b.length;
        const dp = Array.from({ length: m + 1 }, () => new Array(n + 1).fill(0));
        for (let i = 0; i <= m; i++) dp[i][0] = i;
        for (let j = 0; j <= n; j++) dp[0][j] = j;
        for (let i = 1; i <= m; i++) {
          for (let j = 1; j <= n; j++) {
            if (a[i - 1] === b[j - 1]) {
              dp[i][j] = dp[i - 1][j - 1];
            } else {
              dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1;
            }
          }
        }
        return dp[m][n];
      }

      function scoreItem(text, words) {
        const tokens = Array.from(new Set(text.split(/[^a-z0-9]+/g).filter(Boolean)));
        let score = 0;
        for (const w of words) {
          const regex = new RegExp(w, 'gi');
          const matches = text.match(regex);
          if (matches) {
            score += matches.length * 2;
            continue;
          }
          for (const t of tokens) {
            if (t && levenshtein(w, t) <= 1) {
              score += 1;
              break;
            }
          }
        }
        return score;
      }

      function getSnippet(body, words) {
        const lower = body.toLowerCase();
        for (const w of words) {
          const idx = lower.indexOf(w);
          if (idx !== -1) {
            const start = Math.max(0, idx - 40);
            const end = Math.min(body.length, idx + 110);
            return body.slice(start, end).replace(/\n/g, ' ') + '...';
          }
        }
        return body.slice(0, 150).replace(/\n/g, ' ') + '...';
      }

      function slugify(str) {
        return String(str)
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, '-')
          .replace(/^-+|-+$/g, '');
      }

      input.addEventListener('input', () => {
        const q = input.value.trim().toLowerCase();
        results.innerHTML = '';
        if (!q) {
          panel.classList.add('d-none');
          return;
        }

        updatePanelPos();

        const words = q.split(/\s+/).filter(Boolean);
        const matches = [];
        for (const item of searchData) {
          const text = (item.title + ' ' + item.body + ' ' + item.tags.join(' ')).toLowerCase();
          const score = scoreItem(text, words);
          if (score > 0) {
            matches.push({ ...item, score });
          }
        }
        matches.sort((a, b) => b.score - a.score);
        matches.slice(0, 10).forEach(m => {
          const li = document.createElement('li');
          li.className = 'list-group-item';
          const snippet = getSnippet(m.body, words);

          const headingMatches = [];
          const regex = /^#{1,6}\s+(.*)$/gm;
          let hm;
          while ((hm = regex.exec(m.body)) !== null) {
            const text = hm[1].trim();
            const lower = text.toLowerCase();
            if (words.some(w => lower.includes(w))) {
              headingMatches.push({ text, slug: slugify(text) });
            }
          }

          const headingsHtml = headingMatches.length
            ? '<ul class="small mb-0">' +
              headingMatches
                .map(h => `<li><a href="${m.url}#${h.slug}" class="text-decoration-none">${h.text}</a></li>`)
                .join('') +
              '</ul>'
            : '';

          li.innerHTML = `<a href="${m.url}" class="text-decoration-none fw-bold">${m.title}</a><div class="small text-muted search-snippet">${snippet}</div>${headingsHtml}`;
          results.appendChild(li);
        });
        panel.classList.toggle('d-none', matches.length === 0);
      });

      document.addEventListener('click', (e) => {
        if (!panel.contains(e.target) && e.target !== input) {
          panel.classList.add('d-none');
        }
      });

      window.addEventListener('resize', updatePanelPos);
      window.addEventListener('scroll', updatePanelPos);

      // No manual toggle needed - <details> handles open state


      // Keep current page link highlighted and its folder open
        const normalizePath = (p) => p.toLowerCase().replace(/\/?(index\.html)?$/, '');
        const current = normalizePath(window.location.pathname);
        const link = Array.from(document.querySelectorAll('.sidebar-left a')).find(a => {
          const href = a.getAttribute('href');
          if (!href) return false;
          return normalizePath(href) === current;
        });
        if (link) {
          link.classList.add('doc-active');

          let collapseEl = link.closest('.collapse');
          while (collapseEl) {
            collapseEl.classList.add('show');
            const btn = document.querySelector(`[data-bs-target="#${collapseEl.id}"]`);
            if (btn) {
              btn.classList.remove('collapsed');
              btn.setAttribute('aria-expanded', 'true');
            }
            collapseEl = collapseEl.parentElement.closest('.collapse');
          }

          const item = link.closest('.accordion-item');
        if (item) {
          const collapse = item.querySelector('.accordion-collapse');
          if (collapse) collapse.classList.add('show');
          const heading = item.querySelector('.accordion-button');
          if (heading) {
            heading.classList.remove('collapsed');
            heading.setAttribute('aria-expanded', 'true');
          }
        }
      }

      // Ensure anchored headings aren't hidden behind the fixed nav
      function scrollToHash() {
        const { hash } = window.location;
        if (hash) {
          const el = document.getElementById(hash.slice(1));
          if (el) {
            setTimeout(() => el.scrollIntoView(), 50);
          }
        }
      }

      scrollToHash();
        window.addEventListener('hashchange', scrollToHash);

        const tocLinks = Array.from(document.querySelectorAll('.sidebar-right a'));
        if (tocLinks.length) {
          const headings = tocLinks
            .map(a => document.getElementById(a.getAttribute('href').slice(1)))
            .filter(Boolean);
          const highlight = () => {
            let active;
            const offset = window.scrollY + 80;
            for (let i = 0; i < headings.length; i++) {
              if (headings[i].offsetTop <= offset) {
                active = tocLinks[i];
              }
            }
            tocLinks.forEach(link => link.classList.toggle('active', link === active));
          };
          window.addEventListener('scroll', highlight);
          highlight();
        }

      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', onReady);
      } else {
        onReady();
      }

    </script>
  </body>
</html>