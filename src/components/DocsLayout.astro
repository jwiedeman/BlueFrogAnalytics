---
import BaseHead from './BaseHead.astro';
import CustomHeader from './CustomHeader.astro';
import CustomFooter from './CustomFooter.astro';

// Receive headings from page content
const { headings } = Astro.props;

// Build a nested tree structure from docs content
const modules = import.meta.glob('../content/docs/**/*.{md,mdx}', { eager: true });
const docsRaw = import.meta.glob('../content/docs/**/*.{md,mdx}', { eager: true, as: 'raw' });
const blogInfo = import.meta.glob('../content/blog/**/*.{md,mdx}', { eager: true });
const blogRaw = import.meta.glob('../content/blog/**/*.{md,mdx}', { eager: true, as: 'raw' });
function buildTree() {
  const tree = [];
  for (const [filePath, mod] of Object.entries(modules)) {
    let rawKey = filePath.replace('../content/docs/', '').replace(/\.(md|mdx)$/, '');
    if (rawKey === 'index') continue;
    const segments = rawKey.split('/');
    let siblings = tree;
    for (let i = 0; i < segments.length; i++) {
      const segment = segments[i];
      let node = siblings.find(n => n.name === segment);
      if (!node) {
        node = { name: segment, label: segment.replace(/-/g, ' '), path: null, children: [] };
        siblings.push(node);
      }
      siblings = node.children;
      if (i === segments.length - 1) {
        node.path = '/' + rawKey.toLowerCase() + '/';
        node.label = mod.frontmatter?.title || node.label;
      }
    }
  }
  return tree;
}
const docTree = buildTree();

// Determine breadcrumb based on current path
const currentPath = Astro.url.pathname.replace(/\/$/, '').toLowerCase();
function findPath(nodes, parents = []) {
  for (const node of nodes) {
    const nodePath = node.path?.replace(/\/$/, '').toLowerCase();
    if (nodePath === currentPath) {
      return [...parents, node];
    }
    if (node.children?.length) {
      const result = findPath(node.children, [...parents, node]);
      if (result) return result;
    }
  }
  return null;
}
const breadcrumbNodes = findPath(docTree) || [];

const searchIndex = [];
for (const [file, mod] of Object.entries(modules)) {
  const rawKey = file.replace('../content/docs/', '').replace(/\.(md|mdx)$/, '');
  searchIndex.push({
    title: mod.frontmatter?.title || '',
    tags: mod.frontmatter?.tags || [],
    body: docsRaw[file],
    url: '/' + rawKey.toLowerCase() + '/',
  });
}
for (const [file, mod] of Object.entries(blogInfo)) {
  const slug = file.replace('../content/blog/', '').replace(/\.(md|mdx)$/, '');
  searchIndex.push({
    title: mod.frontmatter?.title || '',
    tags: mod.frontmatter?.tags || [],
    body: blogRaw[file],
    url: '/blog/' + slug.toLowerCase() + '/',
  });
}

---
<html lang="en">
  <head>
    <BaseHead />
  </head>
  <body class="docs-layout d-flex flex-column min-vh-100">
    <CustomHeader isDocs={true} />
    <div class="docs-container container-fluid flex-grow-1">
      <aside class="sidebar-left">
        <div class="position-relative mb-3">
          <input id="doc-search" type="search" class="form-control" placeholder="Search docs..." autocomplete="off" />
          <ul id="search-results" class="list-group position-absolute w-100 d-none search-dropdown"></ul>
        </div>
        <div class="accordion" id="docAccordion">
          {(() => {
            function renderNodes(nodes, activeNames, prefix = '') {
              return nodes.map((node, idx) => {
                const id = `${prefix}${idx}`;
                if (node.children?.length) {
                  const isOpen = activeNames.includes(node.name);
                  return (
                    <li class="list-group-item p-0" key={id}>
                      <button class={`btn btn-toggle w-100 text-start${isOpen ? '' : ' collapsed'}`} type="button" data-bs-toggle="collapse" data-bs-target={`#tree-${id}`} aria-expanded={isOpen ? 'true' : 'false'}>
                        {node.label}
                      </button>
                      <div class={`collapse${isOpen ? ' show' : ''}`} id={`tree-${id}`}>
                        <ul class="btn-toggle-nav list-unstyled">
                          {renderNodes(node.children, activeNames, `${id}-`)}
                        </ul>
                      </div>
                    </li>
                  );
                }
                const isActive = node.path?.replace(/\/$/, '').toLowerCase() === currentPath;
                return (
                  <li class="doc-link-item list-group-item p-0" key={id}>
                    <a class={`text-decoration-none d-block ps-4${isActive ? ' doc-active' : ''}`} href={node.path}>{node.label}</a>
                  </li>
                );
              });
            }
            const activeNames = breadcrumbNodes.map(n => n.name);
            return docTree.map((cat, i) => {
              const activeCat = activeNames[0] === cat.name;
              return (
                <div class="accordion-item" key={i}>
                  <h2 class="accordion-header" id={`heading-${i}`}>
                    <button class={`accordion-button${activeCat ? '' : ' collapsed'}`} type="button" data-bs-toggle="collapse" data-bs-target={`#acc-${i}`} aria-expanded={activeCat ? 'true' : 'false'} aria-controls={`acc-${i}`}>
                      {cat.label}
                    </button>
                  </h2>
                  <div id={`acc-${i}`} class={`accordion-collapse collapse${activeCat ? ' show' : ''}`} data-bs-parent="#docAccordion">
                    <div class="accordion-body p-0">
                      <ul class="list-group list-group-flush">
                        {renderNodes(cat.children, activeNames, `${i}-`)}
                      </ul>
                    </div>
                  </div>
                </div>
              );
            });
          })()}
        </div>
      </aside>
      <main id="main-content" class="docs-main">
        {breadcrumbNodes.length ? (
          <nav aria-label="Breadcrumb" class="mb-3">
            <ol class="breadcrumb">
              <li class="breadcrumb-item"><a href="/">Home</a></li>
              {breadcrumbNodes.map((node, idx) => (
                idx < breadcrumbNodes.length - 1 ? (
                  <li class="breadcrumb-item" key={idx}><a href={node.path}>{node.label}</a></li>
                ) : (
                  <li class="breadcrumb-item active" aria-current="page" key={idx}>{node.label}</li>
                )
              ))}
            </ol>
          </nav>
        ) : null}
        <slot />
      </main>
      <aside class="sidebar-right">
        <nav>
          <ul class="list-unstyled">
            {headings?.map(h => (
              <li style={`margin-left: ${h.depth * 0.5}rem`}>
                <a href={`#${h.slug}`}>{h.text}</a>
              </li>
            ))}
          </ul>
        </nav>
      </aside>
    </div>
    <CustomFooter />
    <!-- Docs search logic -->
    <script client:load is:inline define:vars={{ searchIndex }}>
      const onReady = () => {

        const searchData = searchIndex;
        const input = document.getElementById('doc-search');
        const results = document.getElementById('search-results');

      function scoreItem(text, words) {
        let score = 0;
        for (const w of words) {
          const regex = new RegExp(w, 'gi');
          const matches = text.match(regex);
          if (!matches) return 0;
          score += matches.length;
        }
        return score;
      }

      function getSnippet(body, words) {
        const lower = body.toLowerCase();
        for (const w of words) {
          const idx = lower.indexOf(w);
          if (idx !== -1) {
            const start = Math.max(0, idx - 40);
            const end = Math.min(body.length, idx + 110);
            return body.slice(start, end).replace(/\n/g, ' ') + '...';
          }
        }
        return body.slice(0, 150).replace(/\n/g, ' ') + '...';
      }

      input.addEventListener('input', () => {
        const q = input.value.trim().toLowerCase();
        results.innerHTML = '';
        if (!q) {
          results.classList.add('d-none');
          return;
        }
        const words = q.split(/\s+/).filter(Boolean);
        const matches = [];
        for (const item of searchData) {
          const text = (item.title + ' ' + item.body + ' ' + item.tags.join(' ')).toLowerCase();
          const score = scoreItem(text, words);
          if (score > 0) {
            matches.push({ ...item, score });
          }
        }
        matches.sort((a, b) => b.score - a.score);
        matches.slice(0, 10).forEach(m => {
          const li = document.createElement('li');
          li.className = 'list-group-item';
          const snippet = getSnippet(m.body, words);
          li.innerHTML = `<a href="${m.url}" class="text-decoration-none fw-bold">${m.title}</a><div class="small text-muted search-snippet">${snippet}</div>`;
          results.appendChild(li);
        });
        results.classList.toggle('d-none', matches.length === 0);
      });

      document.addEventListener('click', (e) => {
        if (!results.contains(e.target) && e.target !== input) {
          results.classList.add('d-none');
        }
      });

      // No manual toggle needed - <details> handles open state


      // Keep current page link highlighted and its folder open
        const normalizePath = (p) => p.toLowerCase().replace(/\/?(index\.html)?$/, '');
        const current = normalizePath(window.location.pathname);
        const link = Array.from(document.querySelectorAll('.sidebar-left a')).find(a => {
          const href = a.getAttribute('href');
          if (!href) return false;
          return normalizePath(href) === current;
        });
        if (link) {
          link.classList.add('doc-active');

          let collapseEl = link.closest('.collapse');
          while (collapseEl) {
            collapseEl.classList.add('show');
            const btn = document.querySelector(`[data-bs-target="#${collapseEl.id}"]`);
            if (btn) {
              btn.classList.remove('collapsed');
              btn.setAttribute('aria-expanded', 'true');
            }
            collapseEl = collapseEl.parentElement.closest('.collapse');
          }

          const item = link.closest('.accordion-item');
          if (item) {
            const collapse = item.querySelector('.accordion-collapse');
            if (collapse) collapse.classList.add('show');
            const heading = item.querySelector('.accordion-button');
            if (heading) {
              heading.classList.remove('collapsed');
              heading.setAttribute('aria-expanded', 'true');
            }
          }
        }

      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', onReady);
      } else {
        onReady();
      }

    </script>
  </body>
</html>